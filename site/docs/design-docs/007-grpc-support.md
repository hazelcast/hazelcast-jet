---
title: 007 - Extended gRPC Support
description: Improved support for working with gRPC services
---

*Target Release*: 4.1

## Goal

Provide a convenient way to call gRPC services with good performance
as part of a pipeline.

## Background

As part of a data pipeline, it can be necessary to call to a service for
each input item, where the service is external to Jet. Jet currently
provides the `mapUsingService` transform and its variants to supports
this. With this transform, each processor creates a proxy to a
service and then invoke it for each input item. Jet also supports async
services through the use of `mapUsingServiceAsync` which is able to make
several concurrent requests to the same service without any blocking.

[gRPC](https://grpc.io) is a RPC framework for building services and
handles concerns like transport, authentication and stub generation
with support for several different programming languages.

If you have a pipeline where you want to call a gRPC service for each
input item, you can already use the `mapUsingService` transform but this
will not give you the best performance because it will not be making use
of asynchronous calls and each processor will only have a single request
in flight a time. It's still possible to use `mapUsingServiceAsync` in
combination with the non-blocking stub, but this requires writing a lot
of boiler-plate code for each service.

Furthermore, from internal tests it showed that the most efficient way
to use gRPC is to use [bidirectional
streaming](https://grpc.io/docs/guides/concepts/#bidirectional-streaming-rpc)
. To use bidirectional streaming is even less straightforward, requiring
some fairly advanced code to be written as part of the `ServiceFactory`.

As part of the Jet-Python integration, some best practices were
discovered for integrating a Jet pipeline with gRPC, and the goal is
apply these in a more generic way.

## Design

The implementation includes a new module `hazelcast-jet-grpc` which
is added to the `extensions` folder. The module has one main entry
point which is `GrpcServices` which provides the convenience for
creating `ServiceFactory` for the corresponding the gRPC service.

There are two methods added, where one is for unary service and the
other for the bidirectional service.

### Unary Service

Unary service is the most basic gRPC service type, where each request
has a matching response and the service is called in a request-response
fashion.

Given the protobuf definition below for a unary service:

```proto
service Greeter {
   // Sends a greeting
   rpc SayHello (HelloRequest) returns (HelloReply) {}
}
```

We can create the following service factory:

```java

ServiceFactory<?, ? extends GrpcService<HelloRequest, HelloResponse> greeterService = unaryService(
  () -> ManagedChannelBuilder.forAddress("localhost", 5000).usePlaintext(),
  channel -> GreeterGrpc.newStub(channel)::sayHello
);
```

where `GreeterGrpc` is the class auto-generated by the protobuf
compiler.

GrpcService has a very simple interface which only has a single method:

```java
@FunctionalInterface
public interface GrpcService<T, R> {

    /**
     * Calls the requested service and returns a future which will be
     * completed with the result once a response is received.
     */
    @Nonnull
    CompletableFuture<R> call(@Nonnull T input);
}
```

So for every input item, a future containing the output item is created.

The created `ServiceFactory<.., GrpcService>` then can be used with the
`mapUsingServiceAsync` transform as follows:

```java
Pipeline p = Pipeline.create();
p.readFrom(TestSources.items("one", "two", "three", "four"))
  .mapUsingServiceAsync(greeterService, (service, input) -> {
    HelloRequest request = HelloRequest.newBuilder().setName(input).build();
    return service.call(request);
 })
 .writeTo(Sinks.logger());
```

In this implementation, Jet will simply send an async request for each
item, and when the matching response comes it will be emitted further
in the pipeline.

#### Ordering

When a unary service is used, the order of items and their matching
timestamps in a stream are always preserved. The `mapUsingServiceAsync`
transforms has several mechanisms for making sure that input/output
items are matched and they are emitted in the input order.

### Bidirectional Streaming

In bidirectional streaming mode, the requests are sent in a stream and
the replies are also sent as a stream. This can provide better
throughput because there's less overhead per item and there's also
opportunity to send requests in batches.

Given the proto definition below:

```proto
service Greeter {
  // Sends a greeting
  rpc SayHello (stream HelloRequest) returns (stream HelloReply) {}
}
```

We can create the following service factory:

```java
ServiceFactory<?, ? extends GrpcService<HelloRequest, HelloResponse> greeterService = bidirectionalStreamingService(
  () -> ManagedChannelBuilder.forAddress("localhost", 5000).usePlaintext(),
  channel -> GreeterGrpc.newStub(channel)::sayHello
);
```

The way the service is invoked in a `mapUsingServiceAsync` call would
be identical.

```java
Pipeline p = Pipeline.create();
p.readFrom(TestSources.items("one", "two", "three", "four"))
  .mapUsingServiceAsync(greeterService, (service, input) -> {
    HelloRequest request = HelloRequest.newBuilder().setName(input).build();
    return service.call(request);
 })
 .writeTo(Sinks.logger());
```

#### Ordering

When using bidirectional streaming mode, the service implementation can
choose to complete some input items before others, this may have some
unexpected consequences: for example, the request item and the returned
future will not match. As such, **it's required that the service
implementation preserves the input order when completing requests**.

### Error Handling

Any exception thrown from the service is propagated to the returned
future for the input item. The user is expected to handle all exceptions
by using `CompletableFuture.handle()` and map the exception to an
appropriate item, if it's not a fatal failure, otherwise the job will
be failed.

## Future Work

It may be interesting to use a builder pattern for building the gRPC
factory to make the syntax a little simpler. This was investigated but
dropped for now due to increased complexity.

It may be possible to support unordered bidirectional streaming by
requiring a correlation id field to the requests and then matching them
to the responses, but this was also considered out of scope for now.

Currently the deployment and scaling of a gRPC service is left to user,
however it may be an option in the future to have a "Jet-managed" gRPC
bundle which contains the service, and that can be deployed alongside
the Jet nodes.