---
title: Call gRPC service
description: How to call unary or bidirectional streaming gRPC service from a pipeline.
---

The [Stateless Transforms](../api/stateless-transforms.md#mapusingservice)
section shows how to call and use services to transform items in the
pipeline. One way to implement a remote service is using
[gRPC](https://grpc.io/) - an open source universal RPC framework, which
is available for many platforms and languages.

The `hazelcast-jet-grpc` module makes it easy to perform calls to a
gRPC service. Currently, two types of gRPC services are supported:

- unary service
- bidirectional streaming service.

This how to guide shows how to use these services in your pipeline.

## Module dependency

Add a dependency on `hazelcast-jet-grpc` module to use the gRPC services

```xml
<dependency>
    <groupId>com.hazelcast.jet</groupId>
    <artifactId>hazelcast-jet-grpc</artifactId>
    <version>4.1</version>
</dependency>
```

## Unary service

A unary service allows to send a single request and receive a response,
similar to a normal function call.

For example, given the protobuf definition below

```proto
service ProductService {
  rpc ProductInfo (ProductInfoRequest) returns (ProductInfoReply) {}
}
```

We can create the following service factory using
`GrpcServices.unaryService()` method:

```java
ServiceFactory<?, ? extends GrpcService<ProductInfoRequest, ProductInfoReply>> productService = unaryService(
    () -> ManagedChannelBuilder.forAddress("localhost", PORT).useTransportSecurity().usePlaintext(),
    channel -> ProductServiceGrpc.newStub(channel)::productInfo
);
```

The first parameter is a supplier returning a channel builder. Modify
the builder settings as required, e.g. to enable TLS via
`io.grpc.ManagedChannelBuilder.useTransportSecurity()`.  

The second parameter is a function which, given a channel, creates the
stub (the `ProductServiceGrpc` class is auto-generated by the protobuf
compiler) and returns a function that calls the stub given
the input item and the observer. Again you may modify the stub according
to your needs. The returned function will be called once per input item.

The full type of the second parameter is as follows (with wildcards
omitted):

```java
FunctionEx<ManagedChannel, BiConsumerEx<T, StreamObserver<R>>> callStubFn
```

Now the service factory can be used in any of the `mapUsingService*`
methods, preferably the `mapUsingServiceAsync`.

```java
StreamStage<Trade> trades = ...
trades.mapUsingServiceAsync(productService,
(service, trade) -> {
    ProductInfoRequest request = ProductInfoRequest.newBuilder().setId(trade.productId()).build();
    return service.call(request).thenApply(productReply -> tuple2(trade, productReply.getProductName()));
})
```

## Bidirectional streaming service

In a bidirectional streaming service both sides send a sequence of
messages. This usually provides better throughput compared to the unary
service, because all communication happens within a single gRPC call,
eliminating some overheads. Our benchmarks show 1.5x to 3x improvement,
depending on various factors.

For example, given the protobuf definition below

```proto
service BrokerService {
  rpc BrokerInfo (stream BrokerInfoRequest) returns (stream BrokerInfoReply) {}
}
```

We can create the following service factory using
`GrpcServices.bidirectionalStreamingService()` method:

```java
ServiceFactory<?, ? extends GrpcService<BrokerInfoRequest, BrokerInfoReply>> brokerService =
bidirectionalStreamingService(
    () -> ManagedChannelBuilder.forAddress("localhost", PORT).usePlaintext(),
    channel -> BrokerServiceGrpc.newStub(channel)::brokerInfo
);
```

As with the unary service, the first parameter is a supplier returning
a channel builder.

The second parameter is similar as with the unary service, the
difference is that the returned function takes `StreamObserver` as the
input. The stub may be modified as needed.

The full type of the second parameter is as follows (with wildcards
omitted):

```java
FunctionEx<ManagedChannel, FunctionEx<StreamObserver<R>, StreamObserver<T>>> callStubFn
```

Now the service factory can be used in any of the `mapUsingService*`
methods, preferably the `mapUsingServiceAsync`.

```java
StreamStage<Tuple2<Trade, String>> tradesProduct ...
tradesProduct.mapUsingServiceAsync(brokerService,
    (service, t) -> {
        BrokerInfoRequest request = BrokerInfoRequest.newBuilder().setId(t.f0().brokerId()).build();
        return service.call(request)
            .thenApply(brokerReply -> tuple3(t.f0(), t.f1(), brokerReply.getBrokerName()));
})
```

## Maximum performance with batching

If you need to achieve maximum performance and are able to modify the
service itself you may batch the items before doing any call.

For example, given the protobuf definition below (note the
`repeated` keyword):

```proto
service Greeter {
  rpc SayHelloListBidirectional (stream HelloRequestList) returns (stream HelloReplyList) {}
}
message HelloRequestList {
  repeated string name = 1;
}
message HelloReplyList {
  repeated string message = 1;
}
```

We create the service in a way similar to previous example:

```java
ServiceFactory<?, ? extends GrpcService<HelloRequestList, HelloReplyList>> bidiService =
bidirectionalStreamingService(
    () -> ManagedChannelBuilder.forAddress(host, port).usePlaintext(),
    channel -> GreeterGrpc.newStub(channel)::sayHelloListBidirectional
);
```

It is then used differently in the pipeline:

```java
StreamStage<String> stage = ...
stage.mapUsingServiceAsyncBatched(bidiService,
    1024,
    (service, itemList) -> {
        CompletableFuture<HelloReplyList> future =
            service.call(HelloRequestList.newBuilder().addAllName(itemList).build());
        return future.thenApply(HelloReplyList::getMessageList);
    })
})
```

See the [grpc example](https://github.com/hazelcast/hazelcast-jet/tree/master/examples/grpc)
module for a complete code example.
